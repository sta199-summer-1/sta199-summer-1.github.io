---
title: "AE 03: Wrangling flights - Suggested Answers"
categories: 
  - Application exercise
editor: visual
---

::: callout-important
This AE is due Saturday, Jan 28 at 11:59pm.
:::

To demonstrate data wrangling we will use `flights`, a tibble in the **nycflights13** R package. It includes characteristics of all flights departing from New York City (JFK, LGA, EWR) in 2013.

**Note: As we go through the AE, practicing thinking in steps, and reading your code as sentences**

```{r}
#| label: load-packages
#| message: false
#| warning: false

library(tidyverse)
library(nycflights13)
```

The data frame has over 336,000 observations (rows), `r nrow(flights)` observations to be exact, so we will **not** view the entire data frame. Instead we'll use the commands below to help us explore the data.

```{r}
#| label: glimpse-data

glimpse(flights)
```

```{r}
#| label: column-names

names(flights)
```

```{r}
#| label: explore-data

head(flights)
```

The `head()` function returns "A tibble: 6 x 19" and then the first six rows of the `flights` data.

# Tibble vs. data frame

A **tibble** is an opinionated version of the `R` data frame. In other words, all tibbles are data frames, but not all data frames are tibbles!

There are many differences between a tibble and a data frame. The main one is...

1.  When you print a tibble, the first ten rows and all of the columns that fit on the screen will display, along with the type of each column.

Let's look at the differences in the output when we type `flights` (tibble) in the console versus typing `cars` (data frame) in the console.

# Data wrangling with `dplyr`

**dplyr** is the primary package in the tidyverse for data wrangling. [Click here](https://dplyr.tidyverse.org/) for the dplyr reference page. [Click here](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf) for the dplyr cheatsheet.

Quick summary of key dplyr functions[^1]:

[^1]: From [dplyr vignette](https://dplyr.tidyverse.org/articles/dplyr.html)

**Rows:**

-   `filter()`:chooses rows based on column values.
-   `slice()`: chooses rows based on location.
-   `arrange()`: changes the order of the rows
-   `sample_n()`: take a random subset of the rows

**Columns:**

-   `select()`: changes whether or not a column is included.
-   `rename()`: changes the name of columns.
-   `mutate()`: changes the values of columns and creates new columns.

**Groups of rows:**

-   `summarise()`: collapses a group into a single row.
-   `count()`: count unique values of one or more variables.
-   `group_by()`: perform calculations separately for each value of a variable

## The pipe

Before working with more data wrangling functions, let's formally introduce the pipe. The **pipe**, `|>`, is an operator (a tool) for passing information from one process to another. We will use `|>` mainly in data pipelines to pass the output of the previous line of code as the first input of the next line of code.

When reading code "in English", say "and then" whenever you see a pipe.

# Activities

## `select()`

-   Demo: Make a data frame that only contains the variables `dep_delay` and `arr_delay`.

```{r}
#| label: select-vars


flights |>
  select(dep_delay, arr_delay)

```

-   Demo: Make a data frame that keeps every variable except `dep_delay`. Call the new data frame `new.data`

```{r}
#| label: exclude-vars


new.data <- flights |> 
  select(-dep_delay)

```

-   In the console, type `1:10` and hit enter. What happened?

-   Demo: Make a data frame that includes all variables between `year` through `dep_delay` (inclusive). These are all variables that provide information about the departure of each flight.

```{r}
#| label: include-range


flights |> 
  select(dep_delay:year)
```

-   Demo: Use the `select` helper `contains()` to make a data frame that includes the variables associated with the arrival, i.e., contains the string `"arr_"` in the name. Reminder: Thinking about code as **sentences** can help make nesting functions more intuitive.

```{r}
#| label: arr-vars


flights |>
  select(contains("arr_"))

```

-   Why is arr\_ in quotes?

## `slice()`

-   Demo: Display the first five rows of the `flights` data frame.

```{r}
#| label: slice


flights |>
  slice(1:5)

```

-   Demo: Display the last two rows of the `flights` data frame. Hint: `n()` produces the number of the last row in the data set.

```{r}
#| label: last-two


flights |>
  slice((n()-1):n())

flights |>
  slice_tail(n = 2)
```

## `arrange()`

-   Demo: Let's arrange the data by departure delay, so the flights with the **shortest** departure delays will be at the top of the data frame.

```{r}
#| label: arrange-delays


flights |>
  arrange(dep_delay)

```

-   Demo: Now let's arrange the data by descending departure delay, so the flights with the **longest** departure delays will be at the top. Hint, run `?desc` in the console.

```{r}
#| label: arrange-delays-desc

flights |>
  arrange(desc(dep_delay))

```

-   **Your turn (5 minutes):** Create a data frame that only includes the plane tail number (`tailnum`), carrier (`carrier`), and departure delay for the flight with the longest departure delay. What is the plane tail number (`tailnum`) for this flight?

```{r}
#| label: longest-delay

flights |>
  select(tailnum, carrier, dep_delay) |>
  arrange(desc(dep_delay)) |>
  slice(1)
  
```

## `filter()`

-   Demo: Filter the data frame by selecting the rows where the destination airport is RDU. Comment the code below.

```{r}
#| label: rdu

flights |> 
  filter(dest == "RDU")
```

Now, run the following code with one equals sign instead of two. Does it still work?

*(=) is a Assignment operator while (==) is a Equal to operator. (=) is used for assigning the values from right to left while (==) is used for showing equality between values.*

