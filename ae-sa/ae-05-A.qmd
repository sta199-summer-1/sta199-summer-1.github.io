---
title: "AE 05: Joining fisheries - Suggested Answers"
categories: 
  - Application exercise
editor: visual
---

::: callout-important
Go to the [course GitHub organization](https://github.com/sta199-23-2) and locate the repo titled `ae-05-23-YOUR_GITHUB_USERNAME` to get started.

This AE is due Saturday, Feb 4 at 11:59pm.
:::

```{r}
#| label: load-packages-data

library(tidyverse)
library(scales)

fisheries <- read_csv("data/fisheries.csv")
continents <- read_csv("data/continents.csv")
```

## read_csv

Before we get started, I want to introduce `read_csv`.

`read_csv` reads comma delimited files. The first argument to `read_csv()` is the most important: it's the path to the file to read. This function uses the first line of the data for the column names, which is a very common convention. The data might not have column names. You can use col_names = FALSE to tell read_csv() not to treat the first row as headings, and instead label them: `read_csv(path, col_names = FALSE)`.

Another option that commonly needs tweaking is na: this specifies the value (or values) that are used to represent missing values in your file: `read_csv(path, na = "NA")`

## Working with multiple data frames

Often instead of being provided the data you need for your analysis in a single data frame, you will need to bring information from multiple datasets together into a data frame yourself. These datasets will be linked to each other via a column (usually an identifier, something that links the two datasets together) that you can use to join them together.

There are many possible types of joins. All have the format `something_join(x, y)`.

```{r}
#| label: test-joins

x <- tibble(
  value = c(1, 2, 3),
  xcol = c("x1", "x2", "x3")
  )

y <- tibble(
  value = c(1, 2, 4),
  ycol = c("y1", "y2", "y4")
  )

x
y
```

We will demonstrate each of the joins on these small, toy datasets.

**Note: These functions below know to join `x` and `y` by `value` because each dataset has `value` as a column. See for yourself!**

```{r}
#| label: anti-names

names(x)
names(y)
```

### `inner_join()` join all rows in x where there are matching values of y

```{r}
#| label: inner-join

inner_join(x, y)
```

### `left_join()` include all rows in x

```{r}
#| label: left-join

left_join(x , y)
```

### `right_join()` includes all rows of y

```{r}
#| label: right-join

right_join(y, x) 
```

### `full_join()` includes rows for both x and y

```{r}
#| label: full-join

full_join(x, y)
```

### `semi_join()`returns all rows from x that match y

```{r}
#| label: semi-join

semi_join(x, y)
```

### `anti_join()` return all rows from x that do not match with y

```{r}
#| label: anti-join

anti_join(x, y)
```

## Global aquaculture production

The Fisheries and Aquaculture Department of the Food and Agriculture Organization of the United Nations collects data on fisheries production of countries.

**Goal**: Our goal is to create a visualization of the mean share of aquaculture by continent.

Let's start by looking at the `fisheries` data frame.

```{r}
#| label: glimpse-fisheries

glimpse(fisheries)
```

We have the countries, but our goal is to make a visualization by continent. Let's take a look at the continents data frame.

```{r}
#| label: glimpse-continents


glimpse(continents)
```

-   **Your turn (2 minutes):**
    -   Which variable(s) will we use to join the `fisheries` and `continents` data frames?

country

    -   We want to keep all rows and columns from `fisheries` and add a column for corresponding continents. Which join function should we use?

full_join

full_left

-   **Demo:** Join the two data frames and name assign the joined data frame back to `joined_fish`.

```{r}
#| label: join-fisheries-continents

joined_fish <- fisheries |> 
  left_join(continents)
```

-   **Demo:** Take a look at the updated `joined_fish` data frame. There are some countries that were not in `continents`. In the first code chunk, identify which countries these are (they will have `NA` values for `continent`). In the second code chunk, manually update the `continent` information for these countries using the `case_when` function. Finally, check that these updates have been made as intended and no countries are left without continent information.

```{r}
#| label: data-clean
#| eval: false

joined_fish |>
  filter(is.na(continent))

```

Comment through the following code below. Specifically...

-- How is case_when being used? -- Why quotes? -- What does the `~` in words?\
-- What is TRUE doing?

```{r}
#| label: case-when-update

joined_fish <- joined_fish |> 
  mutate(
    continent = case_when(
    country == "Democratic Republic of the Congo" ~ "Africa",
    country == "Hong Kong" ~ "Asia",
    country == "Myanmar" ~ "Asia", 
    TRUE ~ continent
    )
  )

```

-   **Demo:** Add a new column to the `joined_fish` data frame called `aq_prop`. We will calculate it as `aquaculture / total`. Save the resulting frame as `joined_fish`.

```{r add-aq-prop}
#| label: add-aq-prop


joined_fish <- joined_fish |>
  mutate(aq_prop = aquaculture / total)
  
```

-   **Your turn (5 minutes):** Now expand your calculations to also calculate the mean, minimum and maximum aquaculture proportion for continents in the fisheries data. Note that the functions for calculating minimum and maximum in R are `min()` and `max()` respectively.

```{r}
#| label: fisheries-summary-display

joined_fish |>
  group_by(continent) |>
  summarize(
    min_aq_prop = min(aq_prop),
    max_aq_prop = max(aq_prop),
    mean_aq_prop = mean(aq_prop)
  )

```

----------------------- Solution to above answer below -------------------------

-   **Demo:** Using your code above, create a new data frame called `fisheries_summary` that calculates minimum, mean, and maximum aquaculture proportion for each continent in the fisheries data.

```{r}
#| label: fisheries-summary-save

fisheries_summary <- joined_fish |>
  group_by(continent) |>
  summarize(
    min_aq_prop = min(aq_prop),
    max_aq_prop = max(aq_prop),
    mean_aq_prop = mean(aq_prop)
  )
```

-   **Demo:** Then, determine which continent has the largest value of `max_ap`. Take the `fisheries_summary` data frame and order the results in descending order of mean aquaculture proportion.

```{r}
#| label: fisheries-summary-sorted

fisheries_summary |>
  arrange(desc(mean_aq_prop))

```
