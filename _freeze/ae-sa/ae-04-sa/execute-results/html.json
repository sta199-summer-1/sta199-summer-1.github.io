{
  "hash": "fb95ceda31303f9516ffba87ec6d07ee",
  "result": {
    "markdown": "---\ntitle: \"Dplyr + Joins\"\nsubtitle: \"Suggested Answers\"\nformat: html\neditor: visual\n---\n\n\n::: callout-important\nGo to the [course GitHub organization](https://github.com/sta199-summer-1) and locate the repo titled `ae-04-YOUR_GITHUB_USERNAME` to get started.\n\nThis AE is due Friday, May 26th at 11:59pm.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(nycflights13)\nlibrary(scales)\n```\n:::\n\n\n## Data\n\nThese data were collected from 2007 - 2009 by Dr. Kristen Gorman with the Palmer Station Long Term Ecological Research Program, part of the US Long Term Ecological Research Network. The data were imported directly from the Environmental Data Initiative (EDI) Data Portal, and are available for use by CC0 license (\"No Rights Reserved\") in accordance with the Palmer Station Data Policy.\n\n## `filter()`\n\n-   Demo: Filter the data frame by selecting the rows where the destination airport is RDU. Comment the code below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |>\n  filter(dest == \"RDU\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8,163 × 19\n    year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n   <int> <int> <int>    <int>      <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n 1  2013     1     1      800        810     -10     949     955      -6 MQ     \n 2  2013     1     1      832        840      -8    1006    1030     -24 MQ     \n 3  2013     1     1      851        851       0    1032    1036      -4 EV     \n 4  2013     1     1      917        920      -3    1052    1108     -16 B6     \n 5  2013     1     1     1024       1030      -6    1204    1215     -11 MQ     \n 6  2013     1     1     1127       1129      -2    1303    1309      -6 EV     \n 7  2013     1     1     1157       1205      -8    1342    1345      -3 MQ     \n 8  2013     1     1     1240       1235       5    1415    1415       0 MQ     \n 9  2013     1     1     1317       1325      -8    1454    1505     -11 MQ     \n10  2013     1     1     1449       1450      -1    1651    1640      11 MQ     \n# … with 8,153 more rows, 9 more variables: flight <int>, tailnum <chr>,\n#   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#   minute <dbl>, time_hour <dttm>, and abbreviated variable names\n#   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n```\n:::\n\n```{.r .cell-code}\n# = is the same as <-\n```\n:::\n\n\nNow, run the following code with one equals sign instead of two. Does it still work?\n\n*(=) is a Assignment operator while (==) is a Equal to operator. (=) is used for assigning the values from right to left while (==) is used for showing equality between values.*\n\n-   Demo: We can also filter using more than one condition. Here we select all rows where the destination airport is RDU and the arrival delay is less than 0. As we've learned, conditions within functions are separated by a `,`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |>\n  filter(dest == \"RDU\" , arr_delay < 0 )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4,232 × 19\n    year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n   <int> <int> <int>    <int>      <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n 1  2013     1     1      800        810     -10     949     955      -6 MQ     \n 2  2013     1     1      832        840      -8    1006    1030     -24 MQ     \n 3  2013     1     1      851        851       0    1032    1036      -4 EV     \n 4  2013     1     1      917        920      -3    1052    1108     -16 B6     \n 5  2013     1     1     1024       1030      -6    1204    1215     -11 MQ     \n 6  2013     1     1     1127       1129      -2    1303    1309      -6 EV     \n 7  2013     1     1     1157       1205      -8    1342    1345      -3 MQ     \n 8  2013     1     1     1317       1325      -8    1454    1505     -11 MQ     \n 9  2013     1     1     1505       1510      -5    1654    1655      -1 MQ     \n10  2013     1     1     1800       1800       0    1945    1951      -6 B6     \n# … with 4,222 more rows, 9 more variables: flight <int>, tailnum <chr>,\n#   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#   minute <dbl>, time_hour <dttm>, and abbreviated variable names\n#   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n```\n:::\n:::\n\n\nWe can do more complex tasks using logical operators:\n\n| operator      | definition                   |\n|:--------------|:-----------------------------|\n| `<`           | is less than?                |\n| `<=`          | is less than or equal to?    |\n| `>`           | is greater than?             |\n| `>=`          | is greater than or equal to? |\n| `==`          | is exactly equal to?         |\n| `!=`          | is not equal to?             |\n| `x & y`       | is x AND y?                  |\n| `x  | y`      | is x OR y?                   |\n| `is.na(x)`    | is x NA?                     |\n| `!is.na(x)`   | is x not NA?                 |\n| `x %in% y`    | is x in y?                   |\n| `!(x %in% y)` | is x not in y?               |\n| `!x`          | is not x?                    |\n\nThe final operator only makes sense if `x` is logical (TRUE / FALSE).\n\n-   **Your turn (4 minutes):** Describe what the code is doing in words.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> # data set and \n  filter(dest %in% \"RDU\", \n         arr_delay < 0 | dep_delay < 0\n         )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5,308 × 19\n    year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n   <int> <int> <int>    <int>      <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n 1  2013     1     1      800        810     -10     949     955      -6 MQ     \n 2  2013     1     1      832        840      -8    1006    1030     -24 MQ     \n 3  2013     1     1      851        851       0    1032    1036      -4 EV     \n 4  2013     1     1      917        920      -3    1052    1108     -16 B6     \n 5  2013     1     1     1024       1030      -6    1204    1215     -11 MQ     \n 6  2013     1     1     1127       1129      -2    1303    1309      -6 EV     \n 7  2013     1     1     1157       1205      -8    1342    1345      -3 MQ     \n 8  2013     1     1     1317       1325      -8    1454    1505     -11 MQ     \n 9  2013     1     1     1449       1450      -1    1651    1640      11 MQ     \n10  2013     1     1     1505       1510      -5    1654    1655      -1 MQ     \n# … with 5,298 more rows, 9 more variables: flight <int>, tailnum <chr>,\n#   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#   minute <dbl>, time_hour <dttm>, and abbreviated variable names\n#   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n```\n:::\n:::\n\n\n-   What if we want to land at destinations of RDU and GSO? How does the below code change?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |>\n  filter(dest %in% c(\"RDU\", \"GSO\"),\n         arr_delay < 0 | dep_delay < 0\n         )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6,203 × 19\n    year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n   <int> <int> <int>    <int>      <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n 1  2013     1     1      800        810     -10     949     955      -6 MQ     \n 2  2013     1     1      832        840      -8    1006    1030     -24 MQ     \n 3  2013     1     1      851        851       0    1032    1036      -4 EV     \n 4  2013     1     1      917        920      -3    1052    1108     -16 B6     \n 5  2013     1     1     1024       1030      -6    1204    1215     -11 MQ     \n 6  2013     1     1     1127       1129      -2    1303    1309      -6 EV     \n 7  2013     1     1     1157       1205      -8    1342    1345      -3 MQ     \n 8  2013     1     1     1317       1325      -8    1454    1505     -11 MQ     \n 9  2013     1     1     1449       1450      -1    1651    1640      11 MQ     \n10  2013     1     1     1505       1510      -5    1654    1655      -1 MQ     \n# … with 6,193 more rows, 9 more variables: flight <int>, tailnum <chr>,\n#   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#   minute <dbl>, time_hour <dttm>, and abbreviated variable names\n#   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n```\n:::\n:::\n\n\nWhy `c`?\n\nCombine. Use when we have a list larger than one.\n\n## `count()`\n\n-   Demo: Create a frequency table of the destination locations for flights from New York.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |>\n  count(dest)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 105 × 2\n   dest      n\n   <chr> <int>\n 1 ABQ     254\n 2 ACK     265\n 3 ALB     439\n 4 ANC       8\n 5 ATL   17215\n 6 AUS    2439\n 7 AVL     275\n 8 BDL     443\n 9 BGR     375\n10 BHM     297\n# … with 95 more rows\n```\n:::\n:::\n\n\n-   Demo: In which month was there the fewest number of flights? How many flights were there in that month? Hint: Type `?min` into the console.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |>\n  count(month) |>\n  filter(n == min(n))\n```\n:::\n\n\n-   On which date (month + day) was there the largest number of flights? How many flights were there on that day? Comment the code below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |>\n  count(month, day) |>\n  filter(n == max(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n  month   day     n\n  <int> <int> <int>\n1    11    27  1014\n```\n:::\n:::\n\n\n## `mutate()`\n\nUse `mutate()` to create a new variable.\n\n-   Demo: In the code chunk below, `air_time` (minutes in the air) is converted to hours, and then new variable `mph` is created, corresponding to the miles per hour of the flight. Comment each line of code below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  mutate(hours = air_time / 60, \n         mph = distance / hours) |>\nselect(air_time, distance, hours, mph)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 336,776 × 4\n   air_time distance hours   mph\n      <dbl>    <dbl> <dbl> <dbl>\n 1      227     1400 3.78   370.\n 2      227     1416 3.78   374.\n 3      160     1089 2.67   408.\n 4      183     1576 3.05   517.\n 5      116      762 1.93   394.\n 6      150      719 2.5    288.\n 7      158     1065 2.63   404.\n 8       53      229 0.883  259.\n 9      140      944 2.33   405.\n10      138      733 2.3    319.\n# … with 336,766 more rows\n```\n:::\n:::\n\n\n-   **Your turn (4 minutes):** Create a new variable to calculate the percentage of flights in each month. What percentage of flights take place in July?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  count(month) |>\n  mutate(perc = (n / sum(n)) *100)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 3\n   month     n  perc\n   <int> <int> <dbl>\n 1     1 27004  8.02\n 2     2 24951  7.41\n 3     3 28834  8.56\n 4     4 28330  8.41\n 5     5 28796  8.55\n 6     6 28243  8.39\n 7     7 29425  8.74\n 8     8 29327  8.71\n 9     9 27574  8.19\n10    10 28889  8.58\n11    11 27268  8.10\n12    12 28135  8.35\n```\n:::\n:::\n\n\nWe can also use `mutate` to change the type of the same variable (think back to Monday slides)\n\nFirst, show / justify why we can not currently make boxplots of `dep_delay` by month without altering these data. Next write the following code to create boxplots of `dep_delay` by month.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  mutate(month = as.factor(month)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_de…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n   <int> <fct> <int>    <int>      <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n 1  2013 1         1      517        515       2     830     819      11 UA     \n 2  2013 1         1      533        529       4     850     830      20 UA     \n 3  2013 1         1      542        540       2     923     850      33 AA     \n 4  2013 1         1      544        545      -1    1004    1022     -18 B6     \n 5  2013 1         1      554        600      -6     812     837     -25 DL     \n 6  2013 1         1      554        558      -4     740     728      12 UA     \n 7  2013 1         1      555        600      -5     913     854      19 B6     \n 8  2013 1         1      557        600      -3     709     723     -14 EV     \n 9  2013 1         1      557        600      -3     838     846      -8 B6     \n10  2013 1         1      558        600      -2     753     745       8 AA     \n# … with 336,766 more rows, 9 more variables: flight <int>, tailnum <chr>,\n#   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#   minute <dbl>, time_hour <dttm>, and abbreviated variable names\n#   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n```\n:::\n\n```{.r .cell-code}\nglimpse(flights)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 336,776\nColumns: 19\n$ year           <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       <int> 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time <int> 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      <dbl> 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       <int> 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time <int> 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      <dbl> 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        <chr> \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         <int> 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        <chr> \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         <chr> \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           <chr> \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       <dbl> 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       <dbl> 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           <dbl> 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         <dbl> 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      <dttm> 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n```\n:::\n:::\n\n\n## `summarize()`\n\n`summarize()` collapses the rows into summary statistics and removes columns irrelevant to the calculation.\n\nBelow, find the mean `dep_delay` time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  summarize(mean_dep_delay = mean(dep_delay))\n```\n:::\n\n\n**Question: Why did this code return `NA`?**\n\nLet's fix it! We can use `na.rm` to remove `NA`s.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  summarize(mean_dep_delay = mean(dep_delay, na.rm = T))\n```\n:::\n\n\n## `group_by()`\n\n`group_by()` is used for grouped operations. It's very powerful when paired with `summarise()` to calculate summary statistics by group.\n\nHere we find the mean and standard deviation of departure delay for each month. Comment each line of code below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(month) |>\n  summarize(mean_dep_delay = mean(dep_delay, na.rm=T),\n            sd_dep_delay = sd(dep_delay, na.rm=T)\n            )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 3\n   month mean_dep_delay sd_dep_delay\n   <int>          <dbl>        <dbl>\n 1     1          10.0          36.4\n 2     2          10.8          36.3\n 3     3          13.2          40.1\n 4     4          13.9          43.0\n 5     5          13.0          39.4\n 6     6          20.8          51.5\n 7     7          21.7          51.6\n 8     8          12.6          37.7\n 9     9           6.72         35.6\n10    10           6.24         29.7\n11    11           5.44         27.6\n12    12          16.6          41.9\n```\n:::\n:::\n\n\n-   **Your turn (4 minutes):** What is the median departure delay for each airports around NYC (`origin`)?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |>\n  group_by(origin) |>\n  summarize(med_dep_delay = median(dep_delay, na.rm = T))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  origin med_dep_delay\n  <chr>          <dbl>\n1 EWR               -1\n2 JFK               -1\n3 LGA               -3\n```\n:::\n:::\n\n\n## Joining Fisheries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfisheries <- read_csv(\"data/fisheries.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 82 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): country\ndbl (3): capture, aquaculture, total\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\ncontinents <- read_csv(\"data/continents.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 245 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): country, continent\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\n## Working with multiple data frames\n\nOften instead of being provided the data you need for your analysis in a single data frame, you will need to bring information from multiple datasets together into a data frame yourself. These datasets will be linked to each other via a column (usually an identifier, something that links the two datasets together) that you can use to join them together.\n\nThere are many possible types of joins. All have the format `something_join(x, y)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- tibble(\n  value = c(1, 2, 3),\n  xcol = c(\"x1\", \"x2\", \"x3\")\n  )\n\ny <- tibble(\n  value = c(1, 2, 4),\n  ycol = c(\"y1\", \"y2\", \"y4\")\n  )\n\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  value xcol \n  <dbl> <chr>\n1     1 x1   \n2     2 x2   \n3     3 x3   \n```\n:::\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  value ycol \n  <dbl> <chr>\n1     1 y1   \n2     2 y2   \n3     4 y4   \n```\n:::\n:::\n\n\nWe will demonstrate each of the joins on these small, toy datasets.\n\n**Note: These functions below know to join `x` and `y` by `value` because each dataset has `value` as a column. See for yourself!**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"value\" \"xcol\" \n```\n:::\n\n```{.r .cell-code}\nnames(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"value\" \"ycol\" \n```\n:::\n:::\n\n\n### `inner_join()` join all rows in x where there are matching y values\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninner_join(x, y)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"value\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  value xcol  ycol \n  <dbl> <chr> <chr>\n1     1 x1    y1   \n2     2 x2    y2   \n```\n:::\n:::\n\n\n### `left_join()` keeps all values of x\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(x , y)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"value\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  value xcol  ycol \n  <dbl> <chr> <chr>\n1     1 x1    y1   \n2     2 x2    y2   \n3     3 x3    <NA> \n```\n:::\n:::\n\n\n### `right_join()` keeps all rows of y\n\n\n::: {.cell}\n\n```{.r .cell-code}\nright_join(x, y) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"value\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  value xcol  ycol \n  <dbl> <chr> <chr>\n1     1 x1    y1   \n2     2 x2    y2   \n3     4 <NA>  y4   \n```\n:::\n:::\n\n\n### `full_join()` keeping all rows (both x and y)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfull_join(x, y)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"value\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  value xcol  ycol \n  <dbl> <chr> <chr>\n1     1 x1    y1   \n2     2 x2    y2   \n3     3 x3    <NA> \n4     4 <NA>  y4   \n```\n:::\n:::\n\n\n### `semi_join()`returns all rows from x only that match y\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsemi_join(x, y)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"value\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  value xcol \n  <dbl> <chr>\n1     1 x1   \n2     2 x2   \n```\n:::\n:::\n\n\n### `anti_join()` reutrns all rows from x that do not match y\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanti_join(x,y)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"value\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n  value xcol \n  <dbl> <chr>\n1     3 x3   \n```\n:::\n:::\n\n\n## Global aquaculture production\n\nThe Fisheries and Aquaculture Department of the Food and Agriculture Organization of the United Nations collects data on fisheries production of countries.\n\n**Our goal is to create a visualization of the mean share of aquaculture by continent.**\n\n![](images/aquaculture-production-by-continent.png){fig-align=\"center\"}\n\nLet's start by looking at the `fisheries` data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(fisheries)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 82\nColumns: 4\n$ country     <chr> \"Angola\", \"Argentina\", \"Australia\", \"Bangladesh\", \"Brazil\"…\n$ capture     <dbl> 486490, 755226, 174629, 1674770, 705000, 629950, 233190, 8…\n$ aquaculture <dbl> 655, 3673, 96847, 2203554, 581230, 172500, 2315, 200765, 9…\n$ total       <dbl> 487145, 758899, 271476, 3878324, 1286230, 802450, 235505, …\n```\n:::\n:::\n\n\nWe have the countries, but our goal is to make a visualization by continent. Let's take a look at the continents data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(continents)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 245\nColumns: 2\n$ country   <chr> \"Afghanistan\", \"Åland Islands\", \"Albania\", \"Algeria\", \"Ameri…\n$ continent <chr> \"Asia\", \"Europe\", \"Europe\", \"Africa\", \"Oceania\", \"Europe\", \"…\n```\n:::\n:::\n\n\n-   **Your turn (2 minutes):**\n    -   Which variable(s) will we use to join the `fisheries` and `continents` data frames?\n    -   We want to keep all rows and columns from `fisheries` and add a column for corresponding continents. Which join function should we use?\n-   **Demo:** Join the two data frames and name assign the joined data frame back to `fisheries`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfisheries <- fisheries |>\n  left_join(continents)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"country\"\n```\n:::\n\n```{.r .cell-code}\n#same as the following\n\nleft_join(fisheries, continents)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = c(\"country\", \"continent\")\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 82 × 5\n   country    capture aquaculture   total continent\n   <chr>        <dbl>       <dbl>   <dbl> <chr>    \n 1 Angola      486490         655  487145 Africa   \n 2 Argentina   755226        3673  758899 Americas \n 3 Australia   174629       96847  271476 Oceania  \n 4 Bangladesh 1674770     2203554 3878324 Asia     \n 5 Brazil      705000      581230 1286230 Americas \n 6 Cambodia    629950      172500  802450 Asia     \n 7 Cameroon    233190        2315  235505 Africa   \n 8 Canada      874727      200765 1075492 Americas \n 9 Chad        110000          94  110094 Africa   \n10 Chile      1829238     1050117 2879355 Americas \n# … with 72 more rows\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}