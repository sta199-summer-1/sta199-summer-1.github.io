{
  "hash": "5797da80fce20417ba998b3e622733ab",
  "result": {
    "markdown": "---\ntitle: \"AE 07: Hotel bookings\"\ncategories: \n  - Application exercise\neditor: visual\n---\n\n\n::: callout-important\nGo to the [course GitHub organization](https://github.com/sta199-f22-2) and locate the repo titled `ae-07-YOUR_GITHUB_USERNAME` to get started.\n\nThis AE is due Saturday, Sep 25 at 11:59pm.\n:::\n\n## Packages\n\nWe will use the following two packages in this application exercise.\n\n-   **tidyverse**: For data import, wrangling, and visualization.\n-   **skimr**: For summarizing the entire data frame at once.\n-   **scales**: For better axis labels.\n\nTo be productive in R, you need to be familiar with the major types and the operations on these types. Each R object has a un underlying \"type\", which determines the set of possible values for that object. You can find the type of an object using the typeof function.\n\nlogical: a logical value.\n\ninteger: an integer (positive or negative). Many R programmers do not use this mode since every integer value can be represented as a double.\n\ndouble: a real number stored in \"double-precision floatint point format.\"\n\ncomplex: a complex number\n\ncharacter: a sequence of characters, called a \"string\" in other programming languages\n\nlist: a list of named values\n\nNULL: a special type with only one possible value, known as NULL\n\nMore information can be found here: https://statsandr.com/blog/data-types-in-r/\n\n## Why This Matters\n\nWe are going to revisit the mtcars data set. Run ?mtcars to see the definition of each variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(scales)\nlibrary(skimr)\n\nmtcars07 <- read_csv(\"data/mtcars07.csv\" , col_types = NULL)\n\n\nglimpse(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 32\nColumns: 11\n$ mpg  <dbl> 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, 17.8,…\n$ cyl  <dbl> 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 8,…\n$ disp <dbl> 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7, 140.8, 16…\n$ hp   <dbl> 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 180, 180, 180…\n$ drat <dbl> 3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92,…\n$ wt   <dbl> 2.620, 2.875, 2.320, 3.215, 3.440, 3.460, 3.570, 3.190, 3.150, 3.…\n$ qsec <dbl> 16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20.00, 22.90, 18…\n$ vs   <dbl> 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,…\n$ am   <dbl> 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,…\n$ gear <dbl> 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3,…\n$ carb <dbl> 4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2,…\n```\n:::\n:::\n\n\n**3-min** Run the code below to create side-by-side boxplots of the number of mpg cars get versus the type of Engine they have.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\nggplot(\n  aes(x = vs, y = mpg)\n) +\n  geom_boxplot()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Continuous x aesthetic -- did you forget aes(group=...)?\n```\n:::\n\n::: {.cell-output-display}\n![](ae-06-hotels-types-classes-A_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nWhy doesn't this work?\n\n*Answer Here*\n\nEdit the code below to fix the issue.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\n  mutate(vs = as.factor(vs)) |>\nggplot(\n  aes(x = vs, y = mpg)\n) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](ae-06-hotels-types-classes-A_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nNow, calculate the mean number of carburetors for the 32 cars in the data set.\n\n\n::: {.cell}\n\n:::\n\n\nWhy doesn't this work? Fix the code so you can answer the question.\n\n\n::: {.cell}\n\n:::\n\n\n## Type coercion\n\n-   **Demo:** Determine the type of the following vector. And then, change the type to numeric.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- c(\"1\", \"2\", \"3\")\n    typeof(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"character\"\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    as.numeric(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 1 2 3\n    ```\n    :::\n    :::\n\n\n-   **Demo:** Once again, determine the type of the following vector. And then, change the type to numeric. What's different than the previous exercise?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    y <- c(\"a\", \"b\", \"c\")\n    typeof(y)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"character\"\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    as.numeric(y)\n    ```\n    \n    ::: {.cell-output .cell-output-stderr}\n    ```\n    Warning: NAs introduced by coercion\n    ```\n    :::\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] NA NA NA\n    ```\n    :::\n    :::\n\n\n-   **Demo:** Once again, determine the type of the following vector. And then, change the type to numeric. What's different than the previous exercise?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    z <- c(\"1\", \"2\", \"three\")\n    typeof(z)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"character\"\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    as.numeric(z)\n    ```\n    \n    ::: {.cell-output .cell-output-stderr}\n    ```\n    Warning: NAs introduced by coercion\n    ```\n    :::\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1]  1  2 NA\n    ```\n    :::\n    :::\n\n\n-   **Demo:** Suppose you conducted a survey where you asked people how many cars their household owns collectively. And the answers are as follows:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    survey_results <- tibble(cars = c(1, 2, \"three\"))\n    survey_results\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    # A tibble: 3 × 1\n      cars \n      <chr>\n    1 1    \n    2 2    \n    3 three\n    ```\n    :::\n    :::\n\n\n    This is annoying because of that third survey taker who just had to go and type out the number instead of providing as a numeric value. So now you need to update the `cars` variable to be numeric. You do the following\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    survey_results |>\n      mutate(cars = as.numeric(cars))\n    ```\n    \n    ::: {.cell-output .cell-output-stderr}\n    ```\n    Warning in mask$eval_all_mutate(quo): NAs introduced by coercion\n    ```\n    :::\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    # A tibble: 3 × 1\n       cars\n      <dbl>\n    1     1\n    2     2\n    3    NA\n    ```\n    :::\n    :::\n\n\n    And now things are even more annoying because you get a warning `NAs introduced by coercion` that happened while computing `cars = as.numeric(cars)` and the response from the third survey taker is now an `NA` (you lost their data). Fix your `mutate()` call to avoid this warning.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    survey_results |>\n      mutate(\n        cars = if_else(cars == \"three\", \"3\", cars),\n        cars = as.numeric(cars)\n        )\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    # A tibble: 3 × 1\n       cars\n      <dbl>\n    1     1\n    2     2\n    3     3\n    ```\n    :::\n    :::\n\n\n-   Your turn: First, guess the type of the vector. Then, check if you guessed right. I've done the first one for you, you'll see that it's helpful to check the type of each element of the vector first.\n\n    -   `c(1, 1L, \"C\")`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n        v1 <- c(1, 1L, \"C\")\n\n        # to help you guess\n        typeof(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\n        typeof(1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\n        typeof(\"C\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\n        # to check after you guess\n        typeof(v1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n    -   `c(1L / 0, \"A\")`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n        v2 <- c(1L / 0, \"A\")\n\n        # to help you guess\n        typeof(1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\n        typeof(0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\n        typeof(1L / 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\n        typeof(\"A\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\n        # to check after you guess\n        typeof(v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n-   `c(1:3, 5)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n        v3 <- c(1:3, 5)\n\n        # to help you guess\n        typeof(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\n        typeof(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\n        # to check after you guess\n        typeof(v3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n:::\n\n\n    -   `c(3, \"3+\")`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n        v4 <- c(3, \"3+\")\n\n        # to help you guess\n        typeof(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\n        typeof(\"3+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\n        # to check after you guess\n        typeof(v4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n    -   `c(NA, TRUE)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n        v5 <- c(NA, TRUE)\n\n        # to help you guess\n        typeof(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n\n```{.r .cell-code}\n        typeof(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n\n```{.r .cell-code}\n        # to check after you guess\n        typeof(v5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n:::\n\n\n## Hotel bookings\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotels <- read_csv(\"data/hotels.csv\" , col_types = NULL)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: One or more parsing issues, see `problems()` for details\n```\n:::\n\n```{.r .cell-code}\nproblems()\n```\n:::\n\n\nAfter reading in the data set, you should see a Warning message. What does that message say? Explain the output of problems() in your own words.\n\nTake a look at the the following visualization. How are the months ordered? What would be a better order? Then, reorder the months on the x-axis (levels of `arrival_date_month`) in a way that makes more sense. You will want to use a function from the **forcats** package, see <https://forcats.tidyverse.org/reference/index.html> for inspiration and help.\n\n![](images/hotel-prices-months.png){fig-align=\"center\"} Hints:\n\n-- use fct_relevel to order months\n\n-- use case_when to fix the input error\n\n-- calculate mean adr for each group for plot\n\n-- use theme_minimal\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhotels |>\n  mutate(\n  arrival_date_month = fct_relevel(arrival_date_month, \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n              \"July\", \"August\", \"September\", \"October\", \"November\", \"December\")) |>\n  mutate(adr = case_when(\n    is.na(adr) ~ 124,\n    TRUE ~ as.numeric(adr)\n  )) |>\n  group_by(hotel, arrival_date_month) |>\n  summarise(mean_adr = mean(adr)) |>       # calculate mean adr for each group\n  ggplot(aes(\n    x = arrival_date_month,                 # x-axis = arrival_date_month\n    y = mean_adr,                           # y-axis = mean_adr calculated above\n    group = hotel,                          # group lines by hotel type\n    color = hotel)                          # and color by hotel type\n  ) +\n  geom_line() +                             # use lines to represent data\n  theme_minimal() +                         # use a minimal theme\n  labs(\n    x = \"Arrival month\",                 # customize labels\n    y = \"Mean ADR (average daily rate)\",\n    title = \"Comparison of resort and city hotel prices across months\",\n    subtitle = \"Resort hotel prices soar in the summer while ciry hotel prices remain relatively constant throughout the year\",\n    color = \"Hotel type\"\n  ) +\n  scale_y_continuous(labels = label_dollar())\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'hotel'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output-display}\n![](ae-06-hotels-types-classes-A_files/figure-html/label-me-1.png){width=672}\n:::\n:::\n\n\n**Stretch goal:** If you finish the above task before time is up, change the above code so that the y-axis labels are shown with dollar signs, e.g. \\$80 instead of 80. You will want to use a function from the **scales** package, see <https://scales.r-lib.org/reference/index.html> for inspiration and help.\n",
    "supporting": [
      "ae-06-hotels-types-classes-A_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}